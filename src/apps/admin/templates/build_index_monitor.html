{% extends "base.html" %}

{% block title %}Build Index Monitor - Obsidian Vector Search Admin{% endblock %}

{% block head %}
<link rel="stylesheet" href="/static/build_index_monitor.css">
{% endblock %}

{% block content %}
<div class="card">
    <div class="card-header">
        <h3>üöÄ Build Index Control Panel</h3>
    </div>
    <div class="card-body">
        <div class="control-panel">
            <button id="startSyncBtn" class="btn btn-primary" onclick="startSync()">
                ‚ñ∂Ô∏è Start Incremental Sync
            </button>
            <button id="startRebuildBtn" class="btn btn-danger" onclick="startRebuild()">
                üöÄ Start Build Index
            </button>
            <button id="stopBtn" class="btn btn-secondary" onclick="stopOperation()" disabled>
                ‚èπÔ∏è Stop
            </button>
            <button class="btn btn-warning" onclick="clearLog()">üßπ Clear Log</button>
            <button class="btn btn-success" onclick="location.href='/'">üè† Dashboard</button>
        </div>
    </div>
</div>

<div class="progress-section">
    <div class="status info" id="currentStatus">
        Ready to start sync or rebuild operations
    </div>

    <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
        <div class="progress-text" id="progressText">Progress: 0%</div>
    </div>

    <div id="etaDisplay" class="eta-highlight" style="display: none;">
        ETA: <span id="etaTime">calculating...</span>
    </div>
</div>

<div class="stats-grid">
    <div class="stat-card">
        <div class="stat-value" id="totalFiles">-</div>
        <div class="stat-label">üìÅ Total Files</div>
    </div>
    <div class="stat-card">
        <div class="stat-value" id="currentFile">-</div>
        <div class="stat-label">üìÑ Current File</div>
    </div>
    <div class="stat-card">
        <div class="stat-value" id="processed">-</div>
        <div class="stat-label">‚úÖ Processed</div>
    </div>
    <div class="stat-card">
        <div class="stat-value" id="failed">-</div>
        <div class="stat-label">‚ùå Failed</div>
    </div>
    <div class="stat-card">
        <div class="stat-value" id="totalChunks">-</div>
        <div class="stat-label">üì¶ Total Chunks</div>
    </div>
    <div class="stat-card">
        <div class="stat-value" id="totalTime">-</div>
        <div class="stat-label">‚è±Ô∏è Total Time</div>
    </div>
</div>

<div class="log-section">
    <div class="log-header">
        <h4>üìã Process Log</h4>
        <span id="connectionStatus" style="font-size: 14px; color: #6c757d;">Disconnected</span>
    </div>
    <div class="log" id="logContainer"></div>
</div>
{% endblock %}

{% block scripts %}
<script>
    let eventSource = null;
    let startTime = null;
    let totalProcessed = 0;
    let totalFailed = 0;
    let totalChunks = 0;
    let totalDeleted = 0;
    let totalRenamed = 0;
    let currentOperation = null;

    async function startSync() {
        await startOperation('sync', 'Incremental Sync', '/api/sync');
    }

    async function startRebuild() {
        await startOperation('rebuild', 'Build Index', '/api/build-index');
    }

    async function startOperation(operationType, operationName, endpoint) {
        const syncBtn = document.getElementById('startSyncBtn');
        const rebuildBtn = document.getElementById('startRebuildBtn');
        const stopBtn = document.getElementById('stopBtn');

        // Disable both operation buttons
        syncBtn.disabled = true;
        rebuildBtn.disabled = true;
        stopBtn.disabled = false;

        // Update button text based on operation
        if (operationType === 'sync') {
            syncBtn.innerHTML = '<span class="loading-spinner"></span>Syncing...';
        } else {
            rebuildBtn.innerHTML = '<span class="loading-spinner"></span>Rebuilding...';
        }

        // Reset stats
        totalProcessed = 0;
        totalFailed = 0;
        totalChunks = 0;
        totalDeleted = 0;
        totalRenamed = 0;
        currentOperation = operationType;

        startTime = new Date();
        updateCurrentStatus(`Starting ${operationName}...`, 'info');
        updateConnectionStatus('Connecting...');

        try {
            // Use fetch with POST to start the streaming operation
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Accept': 'text/event-stream',
                    'Cache-Control': 'no-cache'
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            addLog(`üîó Connected to ${operationName.toLowerCase()} stream`, 'success');
            updateConnectionStatus('Connected');

            const reader = response.body.getReader();
            const decoder = new TextDecoder();

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value);
                const lines = chunk.split('\n');

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        try {
                            const data = JSON.parse(line.slice(6));
                            handleProgressUpdate(data);
                        } catch (e) {
                            console.error('Failed to parse SSE data:', e);
                            addLog('Error: Failed to parse server response', 'error');
                        }
                    }
                }
            }
        } catch (error) {
            console.error('Stream error:', error);
            addLog(`‚ùå Connection error: ${error.message}`, 'error');
            updateConnectionStatus('Connection Error');
        }

        stopOperation();
    }

    function stopOperation() {
        if (eventSource) {
            eventSource.close();
            eventSource = null;
        }

        const syncBtn = document.getElementById('startSyncBtn');
        const rebuildBtn = document.getElementById('startRebuildBtn');
        const stopBtn = document.getElementById('stopBtn');

        // Reset button states
        syncBtn.innerHTML = '‚ñ∂Ô∏è Start Incremental Sync';
        rebuildBtn.innerHTML = 'üöÄ Start Build Index';
        syncBtn.disabled = false;
        rebuildBtn.disabled = false;
        stopBtn.disabled = true;

        document.getElementById('etaDisplay').style.display = 'none';
        updateCurrentStatus('Operation stopped', 'warning');
        updateConnectionStatus('Disconnected');
        currentOperation = null;
    }

    function updateConnectionStatus(status) {
        document.getElementById('connectionStatus').textContent = status;
    }

    function handleProgressUpdate(data) {
        addLog(`${data.message}`, data.type);

        switch (data.type) {
            case 'status':
                updateCurrentStatus(data.message, 'info');
                if (data.progress !== undefined) {
                    updateProgress(data.progress);
                }
                if (data.total_files !== undefined) {
                    document.getElementById('totalFiles').textContent = data.total_files;
                }
                break;

            case 'progress':
                updateCurrentStatus(data.message, 'info');
                updateProgress(data.progress);
                if (data.current_file !== undefined) {
                    document.getElementById('currentFile').textContent = data.current_file;
                }
                if (data.eta !== undefined && data.eta !== 'calculating...') {
                    document.getElementById('etaTime').textContent = data.eta;
                    document.getElementById('etaDisplay').style.display = 'block';
                }
                break;

            case 'file_complete':
                updateCurrentStatus(data.message, 'success');
                totalProcessed++;
                if (data.chunks) {
                    totalChunks += data.chunks;
                }
                updateStats();
                break;

            case 'complete':
                updateCurrentStatus('üéâ ' + data.message, 'success');
                updateProgress(100);
                document.getElementById('etaDisplay').style.display = 'none';
                if (data.stats) {
                    totalProcessed = data.stats.processed;
                    totalFailed = data.stats.failed;
                    totalChunks = data.stats.total_chunks;
                    totalDeleted = data.stats.deleted || 0;
                    totalRenamed = data.stats.renamed || 0;
                    updateStats();
                }
                if (data.total_time_seconds) {
                    document.getElementById('totalTime').textContent = formatTime(data.total_time_seconds);
                }
                const operationName = currentOperation === 'sync' ? 'Sync' : 'Rebuild';
                stopOperation();
                addLog(`üéä ${operationName} completed successfully! Processed ${totalProcessed} files with ${totalChunks} chunks`, 'success');
                break;

            case 'error':
                updateCurrentStatus('‚ùå ' + data.message, 'error');
                stopOperation();
                break;

            case 'warning':
                updateCurrentStatus('‚ö†Ô∏è ' + data.message, 'warning');
                totalFailed++;
                updateStats();
                break;
        }
    }

    function updateCurrentStatus(message, type) {
        const statusElement = document.getElementById('currentStatus');
        statusElement.textContent = message;
        statusElement.className = `status ${type}`;
    }

    function updateProgress(percentage) {
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');

        progressFill.style.width = Math.min(percentage, 100) + '%';
        progressText.textContent = `Progress: ${Math.round(percentage)}%`;
    }

    function updateStats() {
        document.getElementById('processed').textContent = totalProcessed;
        document.getElementById('failed').textContent = totalFailed;
        document.getElementById('totalChunks').textContent = totalChunks;
    }

    function addLog(message, type = 'info') {
        const logContainer = document.getElementById('logContainer');
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = document.createElement('div');
        logEntry.className = `log-entry ${type}`;

        const icon = {
            'error': '‚ùå',
            'warning': '‚ö†Ô∏è',
            'success': '‚úÖ',
            'info': '‚ÑπÔ∏è'
        }[type] || '‚ÑπÔ∏è';

        logEntry.textContent = `[${timestamp}] ${icon} ${message}`;
        logContainer.appendChild(logEntry);
        logContainer.scrollTop = logContainer.scrollHeight;
    }

    function clearLog() {
        document.getElementById('logContainer').innerHTML = '';
        addLog('Log cleared', 'info');
    }

    function formatTime(seconds) {
        if (seconds < 60) return Math.round(seconds) + 's';
        const minutes = Math.floor(seconds / 60);
        const secs = Math.round(seconds % 60);
        return `${minutes}m ${secs}s`;
    }

    // Update total time periodically when running
    setInterval(() => {
        if (startTime && currentOperation) {
            const elapsed = (new Date() - startTime) / 1000;
            document.getElementById('totalTime').textContent = formatTime(elapsed);
        }
    }, 1000);

    // Initial log entry
    addLog('Admin Monitor ready - choose Sync or Rebuild operation', 'info');
</script>
{% endblock %}