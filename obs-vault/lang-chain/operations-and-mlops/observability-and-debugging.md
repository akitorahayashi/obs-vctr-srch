---
tags:
  - langchain
  - operations
  - mloops
  - debugging
  - observability
  - langsmith
---
# 運用：可観測性とデバッグ

自律型エージェント、特に複数のエージェントが協調するシステムは、その非決定論的な性質から、従来のソフトウェアとは異なるデバッグのアプローチを必要とします。エージェントがなぜ特定の判断を下したのか、どのツールコールが失敗したのか、あるいは予期せぬループに陥っていないか、といった問題は、単純な`print`デバッグでは追跡が困難です。

この複雑性を克服し、開発から運用までの信頼性を確保するための鍵が**可観測性（Observability）**です。LangChainエコシステムでは、この役割を**LangSmith**が担います。

## 1. なぜ可観測性が不可欠なのか

エージェントは、その実行パスが事前に決定されていないため、本質的にブラックボックスになりがちです。可観測性は、このブラックボックスの内部を「観測」し、何が起こったのかを理解可能にするためのプラクティスです。

*   **問題の特定**: エラーが発生した際に、その根本原因がプロンプトの不備なのか、ツールのバグなのか、LLMの幻覚なのかを迅速に切り分けることができます。
*   **パフォーマンスの最適化**: 各ステップのレイテンシやトークン消費量を追跡し、ボトルネックを特定して最適化することができます。
*   **品質の評価**: ユーザーからのフィードバックや自動評価の結果を特定の実行トレースに紐付け、継続的な改善サイクルを回すことができます。

## 2. LangSmith：AIアプリケーションのフライトレコーダー

LangSmithは、LLMアプリケーションの実行を追跡、可視化、デバッグするためのプラットフォームです。エージェントの「心の中」を完全に可視化する「フライトレコーダー」として機能します。

#### セットアップ
LangSmithの利用は非常に簡単です。環境変数を設定するだけで、LangChainの実行が自動的にLangSmithにトレースされるようになります。

```bash
export LANGCHAIN_TRACING_V2="true"
export LANGCHAIN_API_KEY="YOUR_LANGSMITH_API_KEY"
# プロジェクト名を指定すると整理しやすい
export LANGCHAIN_PROJECT="My AI Project"
```

### 2.1. 単一エージェントのデバッグ

`AgentExecutor`で構築された単一エージェントの場合、LangSmithは`Thought -> Action -> Observation`のループ全体を視覚的に追跡します。

LangSmithのUI上では、以下のことが可能です。
*   **実行ステップの確認**: エージェントがどのような思考を経て、どのツールを、どの引数で呼び出したかを確認できます。
*   **プロンプトと出力の検査**: 各ステップでLLMに送信された正確なプロンプトと、LLMからの生の出力を確認できます。これにより、プロンプトの改善点が明確になります。
*   **ツールの入出力確認**: ツールが受け取った入力と、ツールが返した出力を正確に把握し、ツールのバグや予期せぬ挙動を特定できます。

### 2.2. 複雑なLangGraphワークフローのデバッグ

複数のエージェントが協調するLangGraphのワークフローにおいて、LangSmithの価値はさらに高まります。

*   **完全なトレーサビリティ**: LangGraphの実行全体が、一つの親トレースとして記録されます。その下には、各ノードの実行（LLMコール、ツール実行など）が子トレースとして階層的に表示されます。
*   **実行フローの可視化**: グラフの実行フローがツリー形式で表示されます。「researcher」→「writer」→「reviewer」といったノードの遷移が一目瞭然です。レビューによる差し戻し（ループ）が発生した場合も、それも明確に表示されます。
*   **状態（State）のインスペクション**: 各ノードが実行される際に、入力として受け取った`State`オブジェクトの内容と、出力として返した更新内容を詳細に確認できます。これにより、エージェント間の情報伝達が正しく行われているかを検証できます。

## 3. LangGraph Studioによるタイムトラベル・デバッグ

LangSmithの真価は、LangGraph専用のIDEである**LangGraph Studio**と連携することで最大限に発揮されます。この連携は、「タイムトラベル・デバッグ」とも呼ばれる、画期的な開発サイクルを可能にします。

エージェントの実行中にエラーが発生したり、期待と異なる振る舞いをしたりした場合のワークフローは以下の通りです。

1.  **問題の発見**: LangSmithのトレースを確認し、問題が発生しているノードを特定します。
2.  **トレースのクローン**: LangSmithのUI上で、問題のトレースを選択し、「Run in Studio」ボタンをクリックするか、ローカルで実行中のStudioにトレースをインポートします。
3.  **状態の再現**: これにより、ローカルのLangGraph Studioに、問題が発生した**まさにその瞬間のStateオブジェクト**が完全に再現されます。
4.  **コードの修正**: Studioで再現された状態を確認しながら、問題のあったノードのプロンプトを修正するなど、コードの変更を行います。
5.  **途中からの再実行**: 最も強力なのはここです。修正後、ワークフローを最初から実行し直す必要はありません。LangGraph Studioでは、問題のあったノード**から**実行を再開できます。これにより、時間とコストのかかる前のステップをスキップし、修正箇所の動作確認に集中できます。

この`Observe -> Clone -> Patch -> Re-run from Mid-point`という開発サイクルは、従来のデバッグ手法を根本から変革します。非決定論的で再現が困難だったエージェントのバグを、あたかも永続化された検査可能なアーティファクトとして扱うことを可能にします。これは、複雑なAIエージェントを体系的かつ効率的に開発・保守するための、極めて強力なアプローチです。
