---
tags: [regex, search-query, text-processing, developer-tool]
---
# 正規表現学習ロードマップ：ゼロからプロフェッショナルへ

## 序文

正規表現は、単なる文字列検索ツールではありません。それは現代のソフトウェア開発、データ分析、そして日々のテキスト編集作業において不可欠な「ミニ言語」です。テキストエディタでの単純な検索置換から、Webフォームにおけるユーザー入力の検証（バリデーション）、膨大なログファイルからの特定情報の抽出、データベース内のデータ整形まで、その活用範囲は驚くほど多岐にわたります。

一見すると、正規表現の構文は不可解な暗号のように見えるかもしれません。しかし、その基本となる要素を一つひとつ体系的に学べば、誰でもこの強力なツールを自在に使いこなせるようになります。このロードマップは、そのための着実な一歩一歩をナビゲートする羅針盤となることを目指しています。

本稿は、「入門編」「基礎編」「実践編」「応用編」の4段階で構成されています。各段階では、何を学び、それによって何ができるようになるのかを明確に示します。この学習プロセスを最後までやり遂げれば、あなたは業務の現場で自信を持って正規表現を記述し、読解し、そして活用できるプロフェッショナルなスキルを身につけていることでしょう。

### 正規表現の力と普遍性

正規表現の学習は、特定のプログラミング言語やフレームワークの知識とは一線を画します。それは、極めて「移植性の高いスキルセット」への投資です。正規表現は、JavaScript, [[../python-libraries/index_python-libraries.md|Python]], Ruby, Javaといった主要なプログラミング言語はもちろんのこと、Visual Studio Codeのようなテキストエディタ、grepやsedといった[[../python-tools/index_python-tools.md|コマンドラインツール]]、さらにはGoogleスプレッドシートのようなオフィスアプリケーションに至るまで、驚くほど多くの環境で共通して利用できます。

この事実は、一度正規表現の基本を習得すれば、その知識が陳腐化することなく、キャリアを通じて様々な場面で役立ち続けることを意味します。新しい技術を学ぶ際にも、正規表現のスキルは強力な武器となり、あなたの生産性を飛躍的に向上させるでしょう。まさに「一生モノ」のスキルと言えるのです。

---

## 第1部：入門編 - 正規表現の世界へようこそ

### 概要と達成目標

**概要:** この最初の段階では、正規表現が「何であり」「何のために使われるのか」という最も根本的な概念を理解することから始めます。具体的な記号（メタ文字）に触れ、最も単純なパターンの記述と、それが文字列に一致（マッチ）する様子を体験します。

**達成目標:**

1. 正規表現の目的と主な用途を自身の言葉で説明できる。
2. cat のような単純な文字列が、それ自身にマッチするという基本原則を理解する。
3. 最も基本的なメタ文字である .（ドット）、^（キャレット）、$（ドル）、そして \（バックスラッシュ）の役割を理解し、それらを使った簡単なパターンを記述できる。
4. オンラインの正規表現テストツールを使い、自分で書いたパターンが意図通りに機能するかを検証できる。

### 1.1 正規表現とは？ - 文字列のパターンマッチング

#### 概念

正規表現（Regular Expression、しばしばRegExpと略される）とは、「規則性のある文字列のパターンを表現するための、特別な記法で書かれた文字列」です。通常の検索が「特定の単語」を探すのに対し、正規表現は「特定のルールに合致する文字列の集まり」を探すことができます。

例えば、日本の郵便番号は「3桁の数字、ハイフン、4桁の数字」というパターンを持っています。このパターンに合致する文字列（例：「100-0001」）は無数にありますが、正規表現を使えば \d{3}-\d{4} というただ一つの式で、これら全ての郵便番号を表現できます。このように、複雑な文字列の集合を簡潔なパターンで表現するのが正規表現の核心です。

#### 主な用途

正規表現は、主に以下の4つの目的で利用されます。

* **検索:** 特定のパターンを持つ文字列をテキスト中から見つけ出します。例えば、大量のログファイルから「Error」という単語で始まる行だけを効率的に抽出する際に使用します。
* **置換:** パターンに一致した部分を、別の文字列に置き換えます。例えば、文書内の日付フォーマットを「2024-05-20」から「2024/05/20」へ一括で変更する、といった作業が可能です。
* **検証（バリデーション）:** ユーザーが入力したデータが、定められた形式に準拠しているかを確認します。Webサイトのフォームで、電話番号やメールアドレスが正しい形式で入力されているかをチェックするのは、その典型的な例です。
* **抽出・分割:** 文字列の中から必要な部分だけを取り出したり（抽出）、特定の区切り文字で文字列を分割したりします。例えば、URLからドメイン名だけを抜き出す、CSVデータから各列の値を取得する、といった処理に役立ちます。

#### どこで使えるか

正規表現は、プログラマーや開発者だけの専門的なツールではありません。その汎用性の高さから、ITに関わる様々な場面で活用されています。

* **プログラミング言語:** JavaScript, [[../python-libraries/index_python-libraries.md|Python]], Ruby, Java, PHPなど、現代のほとんどのプログラミング言語に標準で組み込まれています。
* **テキストエディタとIDE:** Visual Studio Code, Sublime Text, Atomなどの高機能なテキストエディタや統合開発環境（IDE）では、高度な検索・置換機能として正規表現が利用できます。
* **コマンドラインツール:** LinuxやmacOSのターミナルで使われる grep（検索）や sed（置換）といった[[../python-tools/index_python-tools.md|コマンドラインツール]]は、正規表現を強力にサポートしています。
* **オフィスアプリケーション:** Googleスプレッドシートでは、REGEXMATCH などの専用関数を使って、セル内のデータが特定のパターンに一致するかを判定できます。

### 1.2 最初のメタ文字：. ^ $

正規表現のパターンは、「リテラル文字」と「メタ文字」という2種類の文字で構成されます。

* **リテラル文字:** a や b、1、cat といった、アルファベットや数字などの通常の文字です。これらは、書かれた文字そのものに一致します。例えば、正規表現 cat は、文字列 "cat" にのみマッチします。
* **メタ文字:** 通常の文字とは異なり、「特別な意味を持つ記号」です。これらを使いこなすことが、正規表現をマスターする鍵となります。

ここでは、最も基本的で重要な3つのメタ文字を学びます。

#### . (ドット)

ドット . は、**改行文字を除く任意の1文字**にマッチします。非常に強力で、柔軟なパターンを作成する際に頻繁に使用されます。

* **パターン:** a.c
* **マッチする例:** "abc", "a3c", "a@c", "a c"
* **マッチしない例:** "ac", "abbc"

#### ^ (キャレット)

キャレット ^ は、**文字列の先頭**にマッチする特殊なメタ文字です。これは文字そのものではなく、「位置」にマッチするため、「アンカー」と呼ばれます。

* **パターン:** ^abc
* **マッチする例:** "**abc**def"
* **マッチしない例:** "xyzabc" （"abc" は文字列の先頭にないため）

#### $ (ドル)

ドル $ は ^ と対になるアンカーで、**文字列の末尾**にマッチします。

* **パターン:** xyz$
* **マッチする例:** "uvw**xyz**"
* **マッチしない例:** "xyzabc" （"xyz" は文字列の末尾にないため）

^ と $ を組み合わせることで、「文字列全体」がパターンに厳密に一致するかどうかを検証できます。例えば、^abc$ というパターンは、"abc" という文字列そのものにしかマッチしません。

### 1.3 エスケープ：\ (バックスラッシュ)

もし、. や ^、$ といったメタ文字を、特別な意味ではなく「単なる文字そのもの」として検索したい場合はどうすればよいでしょうか。例えば、IPアドレスに含まれる . や、文末の . を探したい場合です。

このような場面で使うのが**エスケープ**です。メタ文字の直前に \（バックスラッシュ、環境によっては円記号 ¥）を置くことで、そのメタ文字が持つ特別な意味を打ち消し、リテラル文字として扱うことができます。

* **例1：IPアドレスのマッチング**
  * **誤ったパターン:** 192.168.0.1
  * **問題点:** . が「任意の1文字」にマッチするため、"192a168b0c1" のような意図しない文字列にもマッチしてしまいます。
  * **正しいパターン:** 192\.168\.0\.1
* **例2：ファイル拡張子の検証**
  * **誤ったパターン:** \.jpg$
  * **問題点:** ファイル名が "photo.jpg" であることを検証するつもりが、. がエスケープされていないため、"photo.ajpg" や "photo.bjpg" といった文字列にもマッチしてしまいます。これは、レビューやテストで見落とされがちな典型的なバグです。
  * **正しいパターン:** \.jpg$

エスケープの適切な使用は、初心者が最も陥りやすい間違いの一つを防ぐための基本であり、非常に重要です。特に、ユーザー入力の検証などでエスケープを怠ると、意図しない入力を許可してしまい、[[../security/index_security.md|セキュリティ]]上の脆弱性につながる可能性さえあります。メタ文字を文字として扱いたい場合は、必ずエスケープするという習慣を身につけましょう。

### 入門編 演習問題

以下の問題に挑戦して、入門編で学んだ知識を定着させましょう。

問題1
文字列 "cat", "cot", "cut" のいずれかにマッチするが、"coat" や "ct" にはマッチしない正規表現を記述してください。
問題2
ログメッセージの中から、行の先頭が "ERROR:" で始まる行にマッチする正規表現を記述してください。
問題3
文書の中から、文の終わりを示す "end." という文字列にマッチする正規表現を記述してください。（ヒント：エスケープが必要です）

---

**解答と解説**

問題1の解答: c.t
解説: c と t の間に、ドット . を置くことで「任意の1文字」を表現します。これにより、"cat", "cot", "cut" にはマッチしますが、中間の文字が2文字である "coat" や、中間の文字がない "ct" にはマッチしません。
問題2の解答: ^ERROR:
解説: キャレット ^ をパターンの先頭に置くことで、「行の先頭」という条件を指定できます。これにより、行の途中に "ERROR:" があってもマッチせず、先頭にある場合のみに限定できます。
問題3の解答: end\.
解説: ドット . はメタ文字であるため、そのまま end. と記述すると "end" の後に任意の1文字が続く文字列（例："enda", "endb"）にもマッチしてしまいます。文字としての . にマッチさせるためには、バックスラッシュ \ を使って \. とエスケープする必要があります。

---

## 第2部：基礎編 - パターンの構成要素をマスターする

### 概要と達成目標

**概要:** この段階では、正規表現をより柔軟で強力にするための2つの重要な構成要素、「文字クラス」と「量指定子」を学びます。文字クラスによって「指定した文字群のうちのいずれか」を表現できるようになり、量指定子によって「文字やパターンの繰り返し回数」を精密に制御できるようになります。

**達成目標:**

1. `` を使用して、特定の文字集合（例：母音 [aeiou]、特定の記号 [+-*/]）にマッチするパターンを記述できる。
2. [a-z] のような範囲指定や、[^...] のような否定文字クラスを使いこなせる。
3. \d, \w, \s といった、よく使われる文字クラスの短縮形を理解し、適切に利用できる。
4. *, +, ?, {n,m} といった量指定子を使い分け、文字やパターンの繰り返し回数を意図通りに指定できる。

### 2.1 文字クラス ``

文字クラスは、角括弧 `` で文字群を囲むことで、「その中に含まれる**いずれか1文字**」にマッチするパターンを定義します。ドット

. が「何でもよい1文字」であったのに対し、文字クラスはマッチする文字を特定の種類に限定することができます。

* **パターン:** gr[ae]y
* **解説:** [ae] の部分が「a または e のいずれか1文字」にマッチします。
* **マッチする例:** "gray", "grey"
* **マッチしない例:** "grby", "graey"

#### 範囲指定 - (ハイフン)

文字クラス内では、ハイフン - を使うことで、連続した文字の範囲を簡潔に指定できます。

* [0-9] は `` と同じ意味で、0から9までの任意の半角数字1文字にマッチします。
* [a-z] は、aからzまでの任意の半角小文字アルファベット1文字にマッチします。
* [A-Z] は、AからZまでの任意の半角大文字アルファベット1文字にマッチします。

これらの範囲指定は組み合わせることも可能です。例えば、[a-zA-Z0-9] は、任意の半角英数字1文字にマッチします。

#### 否定 ^ (キャレット)

角括弧 `` の**直後**にキャレット ^ を置くと、その意味が反転し、「否定文字クラス」となります。これは、「角括弧内に含まれて**いない**任意の1文字」にマッチします。

* **パターン:** [^0-9]
* **解説:** 0 から 9 までの数字**以外**の任意の1文字にマッチします。
* **マッチする例:** "a", "@", " " (スペース)
* **マッチしない例:** "1", "5"

**注意:** この ^ は、文字クラスの外で使われる「行の先頭」を意味するアンカーとは役割が全く異なる点に注意してください。

#### 文字クラス内のメタ文字

文字クラス `` の中では、ドット . やアスタリスク * といったほとんどのメタ文字は、その特別な意味を失い、単なるリテラル文字として扱われます。例えば、

[akm$] というパターンは、a, k, m, $ のいずれかの文字にマッチします。

ただし、^（否定）、-（範囲指定）、]（クラスの終了）、\（エスケープ）の4つの文字は、文脈によって特別な意味を持つため、リテラル文字として扱いたい場合は注意が必要です。

### 2.2 短縮文字クラス

よく使われる文字クラスには、より簡潔に記述するための便利な短縮形が用意されています。これらを使うことで、正規表現の可読性が向上します。

* **\d (数字):** 任意の半角数字1文字にマッチします。[0-9] と等価です。
* **\D (非数字):** \d の逆で、半角数字以外の任意の1文字にマッチします。[^-9] と等価です。
* **\w (単語構成文字):** 任意の半角英数字とアンダースコア _ にマッチします。[a-zA-Z0-9_] と等価です。
* **\W (非単語構成文字):** \w の逆で、半角英数字とアンダースコア以外の任意の1文字にマッチします。[a-zA-Z0-9_] と等価です。
* **\s (空白文字):** スペース、タブ \t、改行 \n などの空白文字にマッチします。[ \t\n\r\f\v] と等価です。
* **\S (非空白文字):** \s の逆で、空白文字以外の任意の1文字にマッチします。[ \t\n\r\f\v] と等価です。

これらの短縮形を覚えておくと、多くの一般的なパターンを素早く記述できます。

ただし、これらの短縮文字クラスが対象とする文字の範囲は、使用する正規表現エンジンや設定（ロケール）によって挙動が異なる場合があるという点に注意が必要です。例えば、\d や \w がデフォルトではASCII文字（半角文字）のみを対象とし、「１２３」のような全角数字や「あ」のような日本語文字にはマッチしないことがあります。多言語を扱うアプリケーションを開発する際には、この挙動の違いが意図しないバグの原因となる可能性があります。応用編で学ぶUnicodeプロパティ

\p{...} を使うことで、より厳密に文字の種類を指定できますが、現段階では「短縮文字クラスの挙動は環境依存の可能性がある」と覚えておきましょう。

### 2.3 量指定子

量指定子は、その直前にある文字、文字クラス、またはグループが「何回繰り返すか」を指定するためのメタ文字です。これにより、固定長ではない文字列にも柔軟にマッチさせることができます。

#### * (アスタリスク)

直前の要素の「**0回以上**」の繰り返しにマッチします。「0回」も含む、つまりその要素が全く存在しなくてもマッチするのが特徴です。

* **パターン:** ab*c
* **マッチする例:** "ac" (bが0回), "abc" (bが1回), "abbbc" (bが3回)

#### + (プラス)

直前の要素の「**1回以上**」の繰り返しにマッチします。* とは異なり、少なくとも1回は出現する必要があります。

* **パターン:** ab+c
* **マッチする例:** "abc", "abbbc"
* **マッチしない例:** "ac" (bが存在しないため)

#### ? (クエスチョンマーク)

直前の要素が「**0回または1回**」出現する場合にマッチします。これは、ある要素が任意（オプショナル）であることを表現するのに非常に便利です。

* **パターン:** colou?r
* **解説:** u があってもなくてもよい、という意味になります。
* **マッチする例:** "color" (uが0回), "colour" (uが1回)

#### {n,m} (波括弧)

繰り返しの回数をより厳密に、数値で指定することができます。

* {n}: **ちょうどn回**の繰り返し。
  * 例: \d{3} は、3桁の数字（例："123"）にマッチします。
* {n,}: **n回以上**の繰り返し。
  * 例: \d{4,} は、4桁以上の数字（例："1234", "56789"）にマッチします。
* {n,m}: **n回以上、m回以下**の繰り返し。
  * 例: \d{2,4} は、2桁から4桁の数字（例："12", "345", "6789"）にマッチします。

これらの量指定子と文字クラスを組み合わせることで、非常に実用的なパターンを構築できます。例えば、日本の一般的な電話番号 090-1234-5678 は、\d{3}-\d{4}-\d{4} という正規表現で表現できます。

### 基礎編 演習問題

文字クラスと量指定子を組み合わせて、以下の問題に挑戦してみましょう。

問題1
HTMLなどで使われるHEXカラーコードにマッチする正規表現を記述してください。HEXカラーコードは # で始まり、その後に3桁または6桁の16進数（0-9, a-f, A-F）が続きます。
（例: #FFFFFF, #000, #ffAAdd）
問題2
日本の様々な形式の市外局番から始まる電話番号にマッチする正規表現を記述してください。
（例: 03-1234-5678, 090-1234-5678, 0120-123-456）
条件：

* 市外局番は2〜5桁の数字。
* 中間番号は1〜4桁の数字。
* 加入者番号は4桁の数字。
* 各番号はハイフン - で区切られる。

問題3
文字列 "success", "successful", "unsuccessful" にはマッチしますが、"succession" にはマッチしない正規表現を記述してください。

---

**解答と解説**

問題1の解答: ^#[0-9a-fA-F]{3}([0-9a-fA-F]{3})?$
解説:

* ^#: 文字列の先頭が # であることを示します。
* [0-9a-fA-F]{3}: 16進数の文字がちょうど3回繰り返される部分（例: #000）にマッチします。
* ([0-9a-fA-F]{3})?: その後に続く、もう3文字の16進数にマッチします。? が付いているため、この部分はあってもなくても（0回か1回）構いません。これにより、3桁の形式と6桁の形式の両方に対応できます。
* $: 文字列の末尾を示します。

問題2の解答: ^\d{2,5}-\d{1,4}-\d{4}$
解説:

* ^\d{2,5}: 先頭が2〜5桁の数字（市外局番）であることを示します。
* -: ハイフンにマッチします。
* \d{1,4}: 1〜4桁の数字（中間番号）にマッチします。
* -: ハイフンにマッチします。
* \d{4}$: 末尾が4桁の数字（加入者番号）であることを示します。

問題3の解答: ^un?successful?$
解説:

* ^...$: 文字列全体がパターンに一致することを確認します。
* un?: "un" という接頭辞が任意（0回か1回）であることを示します。これにより "success" と "unsuccessful" の両方に対応します。
* success: "success" という文字列にマッチします。
* ful?: "ful" という接尾辞が任意（0回か1回）であることを示します。これにより "successful" にも対応します。
  このパターンは "succession" のように余計な文字が続く場合にはマッチしません。

---

## 第3部：実践編 - 複雑なパターンを組み立てる

### 概要と達成目標

**概要:** これまでに学んだ基本要素（メタ文字、文字クラス、量指定子）を組み合わせ、より構造的で複雑なパターンを構築する技術を学びます。この段階の核となるのは「グループ化」です。グループ化によってパターンを意味のある単位にまとめ、OR条件を指定する「選択」、そしてマッチした部分文字列を再利用する「キャプチャと後方参照」といった強力な機能を使いこなせるようになります。

**達成目標:**

1. () を使用して複数の文字を一つの単位として扱い、その単位に対して量指定子を適用できる。
2. | を使用して、複数のパターンのうちいずれか一つにマッチするOR条件を記述できる。
3. キャプチャグループで取得した文字列を、後方参照 \1 を使って同じパターン内で再利用し、条件付きのマッチングができる。
4. 単語境界 \b を使い、意図しない部分的なマッチを防ぎ、検索の精度を高めることができる。

### 3.1 グループ化 ()

丸括弧 () は、複数の文字やパターンを一つの論理的な単位（グループ）としてまとめるためのメタ文字です。グループ化は、正規表現の表現力を飛躍的に高める、非常に重要な概念です。

#### 量指定子の適用範囲

グループ化の最も基本的な使い方は、量指定子の適用範囲を制御することです。量指定子（*, +, ? など）は、通常、その直前の**1文字**にしか作用しません。しかし、パターンを () で囲むことで、そのグループ全体に対して量指定子を適用できます。

* **パターン1:** ab+
  * **解説:** + は直前の b にのみ作用します。
  * **マッチする例:** "ab", "abb", "abbb"
* **パターン2:** (ab)+
  * **解説:** + はグループ (ab) 全体に作用します。
  * **マッチする例:** "ab", "abab", "ababab"

#### 選択の範囲指定

後述する選択（OR条件）のメタ文字 | と組み合わせる際にも、グループ化は不可欠です。() を使って、OR条件がどの範囲に適用されるかを明確に指定します。

* **パターン1:** apple|orange juice
  * **解説:** これは「"apple"」または「"orange juice"」のどちらかにマッチします。
* **パターン2:** (apple|orange) juice
  * **解説:** こちらは「"apple juice"」または「"orange juice"」のどちらかにマッチします。juice は共通部分として扱われます。

### 3.2 選択 |

パイプ | は、その左右に記述されたパターンの「**どちらか一方**」にマッチする、論理和（OR）を表すメタ文字です。

* **パターン:** cat|dog
* **マッチする例:** "I have a **cat**.", "I have a **dog**."
* **グループ化との組み合わせ:** I love (cat|dog)s.
  * **マッチする例:** "I love **cats**.", "I love **dogs**."

### 3.3 キャプチャと後方参照

グループ化 () には、単にパターンをまとめるだけでなく、もう一つ非常に強力な機能があります。それは、グループにマッチした部分文字列を「**キャプチャ（捕捉）**」し、後で参照するために一時的に記憶する機能です。このキャプチャされた文字列を参照する仕組みを「

**後方参照**」と呼びます。

正規表現におけるグループ化は、「範囲指定」「キャプチャ」「後方参照」という3つの連携した機能を提供する中核的な概念です。() でパターンの範囲を定義するからこそ、意味のある単位がキャプチャでき、キャプチャできるからこそ、後方参照や置換処理での再利用が可能になるのです。これらの機能は独立しているのではなく、一連のプロセスとして理解することが重要です。

#### 後方参照 \N

正規表現のパターン内で \N（N は1から始まる整数）という形式を使うと、N 番目のキャプチャグループがマッチした内容と**全く同じ文字列**にマッチさせることができます。キャプチャグループの番号は、パターン内に出現する左括弧

( の順番で決まります。

実践例1：重複した単語の検出
文書校正などで、"the the" のように同じ単語が誤って連続している箇所を見つけたい場合に後方参照が役立ちます。

* **パターン:** ([a-zA-Z]+) \1
* **解説:**
  1. ([a-zA-Z]+): 1つ以上のアルファベットからなる単語にマッチし、その内容を**1番目のグループとしてキャプチャ**します。例えば、"the the" の最初の "the" にマッチし、"the" という文字列を記憶します。
  2. : 半角スペースにマッチします。
  3. \1: **1番目のグループがキャプチャした内容**（この場合は "the"）と全く同じ文字列にマッチします。
* **結果:** このパターンは "the the", "a a" のような連続した同じ単語にマッチしますが、"the a" のよう異なる単語の連続にはマッチしません。

実践例2：引用符の整合性チェック
文章中で、開始と終了の引用符が正しく対応しているか（"..." や '...'）を確認する際にも有効です。

* **パターン:** (['"])(.*?)\1
* **解説:**
  1. (['"]): シングルクォート ' またはダブルクォート " のどちらかにマッチし、それを**1番目のグループとしてキャプチャ**します。
  2. (.*?): 任意の文字列にマッチします（.*? の詳細は応用編で解説します）。
  3. \1: **1番目のグループがキャプチャした引用符**と全く同じ引用符にマッチします。
* **結果:** 最初に " がマッチした場合、\1 も " にしかマッチしません。これにより、"She's the one\!" のような正しい引用符のペアにはマッチしますが、"She's the one\!' のような不整合なペアにはマッチしません。

#### 置換処理での利用 $N

検索と置換を行う際、置換後の文字列で $N（または \N、環境によります）という形式を使うことで、キャプチャした文字列を再利用できます。これにより、文字列のフォーマット変更などが柔軟に行えます。

* **シナリオ:** 日付フォーマット YYYY-MM-DD を MM/DD/YYYY に変更する。
* **対象文字列:** "2024-05-20"
* **検索パターン:** (\d{4})-(\d{2})-(\d{2})
  * (\d{4}): 年（"2024"）をキャプチャ（グループ1）。
  * (\d{2}): 月（"05"）をキャプチャ（グループ2）。
  * (\d{2}): 日（"20"）をキャプチャ（グループ3）。
* **置換後文字列:** $2/$3/$1
* **置換結果:** "05/20/2024"

### 3.4 アンカーと境界

入門編で学んだ ^（行頭）と $（行末）は、文字ではなく「位置」にマッチする「ゼロ幅アサーション」と呼ばれるものでした。ここでは、もう一つの重要な位置に関するメタ文字、「単語境界」を学びます。

#### 単語境界 \b と \B

\b は、**単語の境界**にマッチするアンカーです。単語の境界とは、「単語構成文字（\w、つまり英数字とアンダースコア）」と「非単語構成文字（\W、スペースや句読点など）」の間、あるいは文字列の先頭・末尾を指します。

\b を使うことで、意図しない部分的なマッチを防ぎ、単語単位での正確な検索が可能になります。

* **シナリオ:** 文字列 "This category is for cats." から、単語 "cat" を見つけたい。
* **パターン1（不正確）:** cat
  * **マッチ結果:** "This **cat**egory is for **cat**s." （"category" の一部にもマッチしてしまう）
* **パターン2（正確）:** \bcat\b
  * **解説:** \b が単語の始まりと終わりにマッチすることを要求します。
  * **マッチ結果:** "This category is for **cat**s." （単語としての "cat" にのみマッチする）

一方、\B は \b の逆で、**単語の境界ではない位置**にマッチします。例えば、

\Bcat\B は "category" の中の "cat" にはマッチしますが、独立した単語 "cat" にはマッチしません。

### 実践編 演習問題

グループ化、選択、後方参照を駆使して、より実践的な問題に挑戦しましょう。

問題1
HTMLの単純な開始タグと終了タグのペア（例: <h1>...</h1>, <p>...</p>）にマッチする正規表現を記述してください。ただし、<h1>...</h2> のように開始タグと終了タグの名前が異なるものにはマッチしないように、後方参照を使ってください。タグの中身は任意の文字列とします。
問題2
"Taro Yamada",25,"Tokyo" のような[[../python-tools/py-excel-automation.md|CSV]]（カンマ区切り）形式のデータ行から、各フィールド（この例では "Taro Yamada", "25", "Tokyo"）をそれぞれ別のキャプチャグループで取得する正規表現を記述してください。フィールドはダブルクォートで囲まれている場合と、囲まれていない数字の場合があります。
問題3
"red car", "blue car", "red bus", "blue bus" のいずれかにマッチする、できるだけ短い正規表現を記述してください。グループ化と選択をうまく活用することがポイントです。

---

**解答と解説**

問題1の解答: <([a-zA-Z][a-zA-Z0-9]*)>.*?</\1>
解説:

* <([a-zA-Z][a-zA-Z0-9]*)>: 開始タグにマッチします。
  * ([a-zA-Z][a-zA-Z0-9]*): タグ名（アルファベットで始まり、英数字が続く）にマッチし、そのタグ名を**グループ1としてキャプチャ**します。
* .*?: タグの中身である任意の文字列にマッチします（最短一致）。
* </\1>: 終了タグにマッチします。
  * \1: 後方参照を使い、**グループ1でキャプチャしたタグ名**と全く同じ文字列を要求します。これにより、開始タグと終了タグの名前が一致することを保証します。

問題2の解答: ^"([^"]*)",(\d+),"([^"]*)"$
解説:

* ^...$: 行全体にマッチさせます。
* "([^"]*)": 最初のフィールド。ダブルクォートに囲まれた、ダブルクォート以外の任意の文字列 [^"]* にマッチし、その中身を**グループ1としてキャプチャ**します。
* ,: カンマ区切り文字にマッチします。
* (\d+): 2番目のフィールド。1つ以上の数字にマッチし、その内容を**グループ2としてキャプチャ**します。
* ,"([^"]*)": 3番目のフィールド。カンマに続き、ダブルクォートで囲まれた内容を**グループ3としてキャプチャ**します。

問題3の解答: (red|blue) (car|bus)
解説:

* (red|blue): 最初の部分が "red" または "blue" であることを示します。
* : 半角スペースにマッチします。
* (car|bus): 後の部分が "car" または "bus" であることを示します。
  このパターンは、4つの組み合わせすべてを効率的に表現しています。

---

## 第4部：応用編 - 正規表現を極める

### 概要と達成目標

**概要:** この最終段階では、正規表現の挙動をより細かく制御し、プロフェッショナルなレベルで使いこなすための高度なテクニックを学びます。量指定子の「貪欲なマッチ」と「怠惰なマッチ」の違いを理解し、マッチ結果に文字列を含めずに複雑な条件を指定できる「先読み・後読み」を習得します。さらに、パフォーマンスや可読性といった、実務で極めて重要となる非機能的な側面についても深く考察します。

**達成目標:**

1. 量指定子のデフォルトの挙動である「貪欲（最長一致）」と、? を追加した「怠惰（最短一致）」の違いを理解し、状況に応じて適切に使い分けられる。
2. 先読み (?=...), (?\!...) と後読み (?<=...), (?<\!...) を用いて、マッチ対象の前後にある文字列を条件として指定できる。
3. 非キャプチャグループ (?:...) を使い、不要なキャプチャによるパフォーマンスへの影響を避け、パターンの可読性を向上させることができる。
4. 正規表現が引き起こす可能性のあるパフォーマンス問題（ReDoS）を認識し、それを回避するための基本的な記述方法を理解する。

### 4.1 貪欲な量指定子と怠惰な量指定子

量指定子（*, +, {n,} など）には、マッチする文字列の長さを決定する2つの異なるモードがあります。

#### 貪欲なマッチ（最長一致）

デフォルトでは、量指定子は**貪欲（Greedy）**に振る舞います。これは、正規表現エンジンが、パターン全体としてマッチが成功する範囲で、**可能な限り最も長い文字列**にマッチしようとすることを意味します。

この挙動は、時に意図しない結果を引き起こします。例えば、HTMLの文字列からタグに囲まれた部分を抜き出そうとする場合を考えてみましょう。

* **対象文字列:** <h1>Title</h1> <p>Paragraph</p>
* **パターン:** <.+>
* **期待するマッチ:** <h1> と </h1> と <p> と </p>
* **実際のマッチ:** <h1>Title</h1> <p>Paragraph</p>

なぜこうなるのでしょうか。貪欲な .+ は、最初の < から始まり、文字列の**最後の >** まで、できるだけ長くマッチしようとします。その結果、中間に存在するタグごと、一つの大きなマッチとして扱われてしまうのです。

#### 怠惰なマッチ（最短一致）

この問題を解決するのが**怠惰（Lazy）**なマッチです。量指定子の直後に ? を追加する（*?, +?, {n,}? など）ことで、その挙動を怠惰モードに切り替えることができます。怠惰な量指定子は、**可能な限り最も短い文字列**にマッチしようとします。

* **対象文字列:** <h1>Title</h1> <p>Paragraph</p>
* **パターン:** <.+?>
* **実際のマッチ:** <h1>, </h1>, <p>, </p>

怠惰な .+? は、最初の < にマッチした後、次に出現する**最初の >** を見つけた時点でマッチを完了させようとします。これにより、各タグが個別に正しくマッチします。

この貪欲と怠惰の選択は、単にマッチする文字列の長さを決めるだけでなく、正規表現エンジンのパフォーマンスにも直接影響します。貪欲な .*hoge のようなパターンは、まず文字列の末尾まで一気に進み、そこから一文字ずつ戻りながら（このプロセスを**バックトラック**と呼びます）hoge を探すため、非効率になることがあります。一方、怠惰な .*?hoge は、hoge が見つかった時点でマッチを完了するため、バックトラックが少なく、より効率的です。どちらのパターンでも同じ結果が得られる場合は、パフォーマンスの観点から、よりバックトラックが少ない怠惰なパターンを選択することがベストプラクティスです。

### 4.2 先読みと後読み (Lookarounds)

先読みと後読みは、^, $, \b と同じく「ゼロ幅アサーション」の一種です。これらは、**マッチ結果にその部分を含めずに（文字列を消費せずに）**、現在のマッチ位置の前後の文脈をチェックするための非常に高度な機能です。

#### 肯定的な先読み (?=...)

「**...が後に続く位置**」にマッチします。つまり、... の部分が実際に存在するかどうかをチェックしますが、... の文字列自体はマッチ結果に含まれません。

実践例：パスワードの強度チェック
「8文字以上で、かつ数字を1文字以上含む」という条件を検証する場合、先読みが非常に有効です。

* **パターン:** ^(?=.*\d).{8,}$
* **解説:**
  1. ^: 文字列の先頭に位置を合わせます。
  2. (?=.*\d): ここが先読みの部分です。「現在位置（先頭）から見て、どこかに数字（.*\d）が存在するか」をチェックします。このチェックは成功しても失敗しても、文字列を消費しない（カーソル位置は先頭のまま）のがポイントです。
  3. .{8,}: 先頭から末尾まで、任意の文字が8文字以上あることを検証します。
* **結果:** このパターンは、2つの条件（「数字を含む」かつ「8文字以上」）を同時に満たす文字列にのみマッチします。

先読みはゼロ幅であるため、カーソル位置を消費しません。この特性を利用すると、パスワード検証の例のように、同じ位置から複数の異なる条件を重ねて（AND条件として）検証することが可能になります。これは、複数の正規表現を組み合わせなければ実現できないような複雑な論理を、一つの式でエレガントに表現するための強力なテクニックです。

#### 否定的な先読み (?\!...)

「**...が後に続かない位置**」にマッチします。特定の文字列を含まない、という除外条件を指定するのに役立ちます。

* **パターン:** q(?\!u)
* **解説:** q にマッチしますが、その直後に u が続かない場合に限ります。
* **マッチする例:** "Ira**q**"
* **マッチしない例:** "quit"

#### 肯定的な後読み (?<=...)

「**...が前に来る位置**」にマッチします。先読みの逆で、左側（過去）の文脈をチェックします。

* **パターン:** (?<=\$)\d+
* **解説:** ドル記号 $ の直後にある1つ以上の数字にマッチします。
* **対象文字列:** "Price: $100"
* **マッチ結果:** "100" （$ は条件として使われるだけで、マッチ結果には含まれません）

#### 否定的な後読み (?<\!...)

「**...が前に来ない位置**」にマッチします。

* **パターン:** (?<\!#)\s*import
* **解説:** 行頭のコメント記号 # が前にない import 文にマッチします。
* **マッチする例:** " **import** os"
* **マッチしない例:** "# import sys"

**注意:** 後読み機能、特に可変長の文字列を伴う後読みは、正規表現エンジンによってはサポートされていない場合があるため、使用する環境のドキュメントを確認することが重要です。

### 4.3 その他の高度な機能

#### 非キャプチャグループ (?:...)

グループ化 () はしたいが、後方参照のためのキャプチャは不要な場合があります。そのような場合は、(?:...) という構文を使用します。これにより、後方参照のためのメモリ確保やグループ番号の割り振りがスキップされるため、パフォーマンスがわずかに向上し、後方参照を使う他のグループの番号がずれないというメリットがあります。また、キャプチャの意図がないことを明示することで、パターンの可読性も向上します。

* **パターン:** (?:red|blue) car
* **解説:** "red car" または "blue car" にマッチしますが、"red" や "blue" はキャプチャされません。

#### フラグ（修飾子）

正規表現の末尾に付けることで、パターン全体のマッチング挙動を変更するオプションです。

* i (ignoreCase): 大文字と小文字を区別せずにマッチングを行います。/cat/i は "cat", "Cat", "CAT" のいずれにもマッチします。
* g (global): 文字列内で最初にマッチした箇所で検索を止めず、文字列全体を検索して全てのマッチを見つけ出します。
* m (multiline): このフラグを有効にすると、アンカー ^ と $ が文字列全体の先頭・末尾だけでなく、各行の先頭・末尾にもマッチするようになります。複数行にわたるテキストを処理する際に重要です。
* s (dotAll): デフォルトでは改行文字にマッチしないドット . が、改行文字にもマッチするようになります。

#### Unicodeプロパティ \p{...}

\p{...} 構文を使うと、文字が持つUnicodeのプロパティに基づいてマッチさせることができます。これにより、\w や \d よりも遥かに精緻で、多言語に対応した文字クラスを定義できます。u フラグの指定が必要なことが多いです。

* \p{Script=Hiragana}: ひらがな全てにマッチします。
* \p{Currency_Symbol}: $ や €, ¥ などの通貨記号にマッチします。

### 4.4 正規表現の落とし穴とベストプラクティス

#### 破滅的なバックトラッキング (Catastrophic Backtracking / ReDoS)

正規表現は非常に強力ですが、書き方によっては深刻なパフォーマンス問題を引き起こすことがあります。特に、曖昧な繰り返しパターンが入れ子になっている場合（例: (a+)+ や (a|a)*）、正規表現エンジンはマッチを試みるために膨大な数のバックトラック（探索のやり直し）を行う可能性があります。入力文字列が長くなるにつれて、この計算量は指数関数的に増加し、アプリケーションがフリーズしたり、サーバーリソースを枯渇させたりすることがあります。これは **ReDoS (Regular expression Denial of Service)** と呼ばれるサービス不能攻撃の原因となり得ます。

**回避策:**

* 入れ子になった量指定子を避ける。
* できるだけ具体的なパターンを書く（例: .* ではなく [^"]* を使う）。
* 怠惰な量指定子 *? や +? を適切に使う。

#### 可読性と保守性

正規表現は、複雑になりすぎると書いた本人でさえ解読が困難になることがあります。これは「書き捨て」のコードを生み、将来のメンテナンスを著しく困難にします。

**ベストプラクティス:**

* 複雑な正規表現にはコメントを残す（言語やツールが許せば）。
* 一つの巨大な正規表現で全てを解決しようとせず、複数の単純な正規表現やプログラムコードによる処理と組み合わせる。
* 非キャプチャグループ (?:...) を適切に使い、パターンの意図を明確にする。

#### エンジンの違い（Flavor）

正規表現の構文やサポートされる機能は、使用する言語やツール（PCRE, JavaScript, Python, Rubyなど）によって微妙に異なります。これを「Flavor（風味）」の違いと呼びます。特に、後読みのサポート状況や、

\s がマッチする空白文字の種類、$ が行末の改行にマッチするかどうかなど、細かい挙動に差があるため注意が必要です。開発時には、対象とする環境のドキュメントを確認し、オンラインツールでテストすることが不可欠です。

### 応用編 演習問題

これまでに学んだ高度な機能を組み合わせて、実務に近いシナリオの問題に挑戦しましょう。

問題1
複数行のテキストの中から、キーワード "TODO" を含むが、その行がコメントアウト（行頭が #）されていない行全体にマッチする正規表現を記述してください。（ヒント：m フラグと否定後読みが有効です）
問題2
1,000,000 のように3桁ごとにカンマで区切られた金額表記の文字列から、カンマを取り除いた数値部分 1000000 を抽出（置換処理で実現）してください。
問題3
ユーザーが設定するパスワードが、以下の3つの条件をすべて満たすか検証するための、単一の正規表現を記述してください。

1. 8文字以上である。
2. 大文字のアルファベットを少なくとも1文字含む。
3. 小文字のアルファベットを少なくとも1文字含む。
4. 数字を少なくとも1文字含む。
   （ヒント：複数の先読みを組み合わせます）

---

**解答と解説**

問題1の解答: ^(?<\!#).*TODO.*$ （m フラグ付き）
解説:

* m フラグにより、^ と $ が各行の先頭と末尾にマッチするようになります。
* ^: 行の先頭にマッチします。
* (?<\!#): 否定後読みです。「直前に # が**ない**位置」にマッチしますが、これは実質的に行頭に # がないことを確認しています。
* .*TODO.*: 行の中に "TODO" という文字列が含まれていることを示します。
* $: 行の末尾にマッチします。

**問題2の解答:**

* **検索パターン:** ,
* **置換後文字列:** （空文字列）
* **解説:** この問題は、正規表現の強力さだけでなく、時には単純な解決策が最善であることを示唆しています。金額文字列からカンマを検索し、それを空文字列に置換するだけで目的は達成できます。複雑な正規表現は不要です。

問題3の解答: ^(?=.*[A-Z])(?=.*[a-z])(?=.*\d).{8,}$
解説:

* ^: 文字列の先頭にアンカーします。
* (?=.*[A-Z]): 先読みを使い、「どこかに大文字が1文字以上あること」をチェックします。
* (?=.*[a-z]): 同様に、「どこかに小文字が1文字以上あること」をチェックします。
* (?=.*\d): 同様に、「どこかに数字が1文字以上あること」をチェックします。
* .{8,}: これまでのチェックがすべて成功した後、実際に文字列を消費して「全体の長さが8文字以上であること」を検証します。
* $: 文字列の末尾にアンカーします。
  このパターンは、先読みが文字列を消費しない特性を最大限に活用し、複数のAND条件を一つの式で簡潔に表現しています。

---

## 第5部：総仕上げ - 総合演習問題

これまでの学習の集大成として、実世界のシナリオに基づいた総合演習問題に取り組みます。この課題は、入門編から応用編までで学んだ知識を総動員して解決する必要があります。

### シナリオ設定

あなたはWebサーバーの管理者です。日々生成される膨大なApacheのアクセスログファイルから、特定のエラー情報を抽出し、分析用のレポートとして整形するタスクを任されました。正規表現を駆使して、以下の要件を満たす処理を実装してください。

### 対象ログデータ（サンプル）

127.0.0.1 - - [10/Oct/2023:13:55:36 +0900] "GET /index.html HTTP/1.1" 200 2326
192.168.1.1 - frank [10/Oct/2023:13:55:38 +0900] "POST /login.php HTTP/1.1" 401 512
72.14.192.32 - - [10/Oct/2023:14:01:02 +0900] "GET /images/logo.png HTTP/1.1" 200 12544
192.168.1.2 - alice [10/Oct/2023:14:02:15 +0900] "GET /private/data.json HTTP/1.1" 403 201
216.58.206.99 - - [10/Oct/2023:14:05:40 +0900] "GET /robots.txt HTTP/1.1" 404 198

### 要件

1. **エラーログの抽出:** ステータスコードが4xx（クライアントエラー）または5xx（サーバーエラー）の行のみにマッチする正規表現を作成してください。
2. **情報キャプチャ:** マッチした各エラーログから、以下の4つの情報をそれぞれキャプチャグループを使って取得してください。
   * IPアドレス (例: 192.168.1.1)
   * 日時 (例: 10/Oct/2023:13:55:38 +0900)
   * HTTPメソッドとリクエストパス (例: POST /login.php)
   * ステータスコード (例: 401)
3. レポート形式への置換: キャプチャした情報を利用して、以下のCSV形式のレポート行に整形してください。
   "日時","IPアドレス","ステータスコード","リクエスト"
   （例: "10/Oct/2023:13:55:38 +0900","192.168.1.1","401","POST /login.php"）

### 解答と解説

この課題は、3つのステップに分けて考えます。

#### ステップ1：エラー行のマッチング

まず、ステータスコードが4xxまたは5xxの行を特定します。ログの構造を見ると、ステータスコードは " の後にスペースを挟んで3桁の数字として記録されています。

* **パターン:** \d{2}
* **解説:** スペースの後に、4 または 5 で始まる3桁の数字が続くパターンです。`` で最初の桁を、\d{2} で残りの2桁を指定します。

このパターンを含む行全体にマッチさせるには、前後に .* を付けた ^.* \d{2}.*$ のような形になります。

#### ステップ2：情報のキャプチャ

次に、必要な4つの情報をキャプチャグループ () で囲んでいきます。

* **IPアドレス:** 行の先頭にある、スペース以外の文字の連続です。^(\S+)
* **日時:** [ と ] に囲まれています。中身は任意の文字列なので、怠惰な量指定子 .*? を使って \[(.*?)\] とします。
* **リクエスト:** " と " に囲まれています。同様に "(.*?)" とします。
* **ステータスコード:** ステップ1で考えたパターンをグループ化し、(\d{2}) とします。

これらを組み合わせると、以下のようになります。

^(\S+) -.*? \[(.*?)\] "(.*?)" (\d{2}).*

* ^(\S+): グループ1（IPアドレス）
* -.*?: ユーザー名など不要な部分をスキップします。
* \[(.*?)\]: グループ2（日時）
* "(.*?)": グループ3（リクエスト）
* (\d{2}): グループ4（ステータスコード）
* .*: 残りの部分にマッチします。

#### ステップ3：レポート形式への置換

最後に、キャプチャしたグループを置換機能で再構成します。多くのツールでは $N または \N の形式で後方参照を利用できます。

* **置換後文字列:** "$2","$1","$4","$3"
* **解説:**
  * "$2": グループ2（日時）
  * "$1": グループ1（IPアドレス）
  * "$4": グループ4（ステータスコード）
  * "$3": グループ3（リクエスト）

#### 最終的なパターンと置換

検索パターン:
^(\S+) - (?:.*? \[(.*?)\] "(.*?)" (\d{2}).*|.*)$
置換後文字列:
"$2","$1","$4","$3"
この演習は、単純な文字列マッチングから始まり、文字クラス、量指定子、グループ化、キャプチャ、そして置換における後方参照まで、このロードマップで学んだほぼ全ての主要な概念を統合したものです。このような実践的な課題を解決できるようになったあなたは、もはや正規表現の初心者ではありません。自信を持って、日々の業務にこの強力なスキルを活用してください。

---

## 付録

### A.1 メタ文字・構文クイックリファレンス

日々の業務で正規表現を使用する際に役立つ、主要なメタ文字と構文の早見表です。

| 構文 (Syntax) | 名称 (Name) | 解説 (Description) | 使用例 (Example) |
| :---- | :---- | :---- | :---- |
| **文字クラス** |  |  |  |
| . | ドット | 改行を除く任意の1文字にマッチします。 | a.c → "abc", "a3c" |
| [abc] | 文字クラス | a, b, c のいずれか1文字にマッチします。 | gr[ae]y → "gray", "grey" |
| [^abc] | 否定文字クラス | a, b, c 以外の任意の1文字にマッチします。 | [^0-9] → "a", "%" |
| [a-z] | 範囲指定 | a から z までの任意の1文字にマッチします。 | [A-Z] → "A", "B" |
| \d | 数字 | 任意の半角数字1文字。[0-9] と等価です。 | \d\d → "12", "99" |
| \w | 単語構成文字 | 任意の半角英数字とアンダースコア。[a-zA-Z0-9_] と等価です。 | \w+ → "word_1" |
| \s | 空白文字 | スペース、タブ、改行などの空白文字にマッチします。 | Hello\sWorld → "Hello World" |
| \D, \W, \S | 否定短縮クラス | それぞれ \d, \w, \s の逆の意味になります。 | \D → "a", "#" |
| **アンカー** |  |  |  |
| ^ | キャレット | 文字列または行の先頭にマッチします。 | ^Start → "**Start** of line" |
| $ | ドル | 文字列または行の末尾にマッチします。 | end$ → "Line **end**" |
| \b | 単語境界 | 単語の始まりまたは終わりにマッチします。 | \bcat\b → "the **cat** is" |
| \B | 非単語境界 | 単語の境界ではない位置にマッチします。 | \Bcat\B → "ab**cat**ion" |
| **量指定子** |  |  |  |
| * | アスタリスク | 直前の要素の0回以上の繰り返し（貪欲）。 | ab*c → "ac", "abc", "abbc" |
| + | プラス | 直前の要素の1回以上の繰り返し（貪欲）。 | ab+c → "abc", "abbc" |
| ? | クエスチョンマーク | 直前の要素の0回または1回の出現（貪欲）。 | colou?r → "color", "colour" |
| {n} | 波括弧（固定） | 直前の要素のちょうどn回の繰り返し。 | \d{3} → "123" |
| {n,} | 波括弧（n回以上） | 直前の要素のn回以上の繰り返し。 | \d{2,} → "12", "1234" |
| {n,m} | 波括弧（範囲） | 直前の要素のn回以上m回以下の繰り返し。 | \d{2,4} → "12", "1234" |
| *?, +?, ?? | 怠惰な量指定子 | 最短一致。可能な限り短い文字列にマッチします。 | <.+?> → <h1> |
| **グループと参照** |  |  |  |
| (abc) | キャプチャグループ | パターンをグループ化し、マッチした内容をキャプチャします。 | (ab)+ → "ab", "abab" |
| \1, \2 | 後方参照 | N番目のキャプチャグループと同じ文字列にマッチします。 | (\w) \1 → "a a" |
| (?:abc) | 非キャプチャグループ | パターンをグループ化しますが、キャプチャはしません。 | `(?:a |
| a|b | 選択 | a または b のいずれかにマッチします。 | cat|dog → "cat", "dog" |
| **先読み・後読み** |  |  |  |
| (?=...) | 肯定的な先読み | ... が後に続く位置にマッチします（文字列は消費しない）。 | Windows(?=XP) → "**Windows**XP" の "Windows" |
| (?\!...) | 否定的な先読み | ... が後に続かない位置にマッチします。 | q(?\!u) → "Ira**q**" |
| (?<=...) | 肯定的な後読み | ... が前に来る位置にマッチします。 | (?<=\$)\d+ → "$**100**" の "100" |
| (?<\!...) | 否定的な後読み | ... が前に来ない位置にマッチします。 | (?<\!\d)10 → "item **10**" |

### A.2 学習に役立つオンラインツールと参考文献

正規表現の学習と実践において、以下のツールや資料は非常に役立ちます。

#### オンラインテスター

正規表現をリアルタイムでテストし、マッチングの様子を視覚的に確認できるWebサイトです。パターンを書きながら即座にフィードバックが得られるため、学習効率が飛躍的に向上します。

* **Regex101:** 高機能で最も人気のあるツールの一つ。パターンの各部分がどのように機能しているかの詳細な解説や、パフォーマンスに関する警告も表示してくれます。
* **Rubular:** Rubyベースの正規表現エンジンで動作する、シンプルで使いやすいテスターです。
* **Scriptular:** JavaScriptベースの正規表現エンジンで動作します。Web開発者にとって特に便利です。

#### インタラクティブな学習サイト

ゲーム感覚で演習問題に取り組むことで、楽しくスキルを定着させることができます。

* **RegexOne:** ステップバイステップのレッスンとインタラクティブな演習で、正規表現の基礎を学べます。
* **Regex Crossword:** 正規表現をヒントにしたクロスワードパズルを解くことで、パターンの読解力を鍛えられます。
